\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{array}
\usepackage{listings}
\usepackage{multirow}

\geometry{lmargin=2cm,rmargin=2cm,vmargin=2cm,hmargin=2cm}

\lstset{language=Java,basicstyle=\small}


\begin{document}
\clearpage
\vspace*{\fill}
\begin{center}
\begin{minipage}{.6\textwidth}
\title{Sonar fixer}
\author{Clement Maxime - Piorun Jordan}
\date{\today}
\maketitle
\end{minipage}

\end{center}
\vfill % equivalent to \vspace{\fill}
\clearpage

\newpage

\section{Introduction}
\par Pour de nombreux projets, nous avons recours a Sonar, un logiciel permettant de mesurer la qualité de notre code en continu. Le rapport de Sonar classe les améliorations a apporter en différentes catégories, des erreurs critiques aux simples informations.
\\
\par Pour notre projet, nous somme parti d'un simple constat : les erreurs sonar sont souvent les mêmes, et un nombre considérable d'entre elles pourrait être corrigées de façon automatique. Cela passe par deux étapes : premièrement il faut repérer le morceau de code qui est à l'origine de l'erreur, puis il faut ensuite le remplacer avec du code équivalent.
\\
\par pour ces deux besoins, nous avons choisis d'utiliser Spoon, une librairie développée à l'Inria permettant d'analyser et de transformer du code Java.

\newpage
\section{Analyse du code}
\subsection{Le scope}

\par Avant même de s'intéresser à la partie technique de ce projet, nous avons du établir la liste des erreurs que nous voulions corriger.
\\
\par Sonar classe les erreurs en 5 catégories : bloquantes, critiques, majeures, mineures et informatives. Parmi celles ci, nous avons jugé que les plus pertinentes, mais aussi les plus urgentes à corriger sont les erreurs majeures.
\\
\par En effet, les deux catégories au dessus gênent le bon fonctionnement du programme et sont donc en toute logique détectée au préalable par le développeur.
\\
\par Les niveaux de sévérité moins importants quant à eux relèvent plus de conventions de codages, de format de code ou autres problèmes pouvant gêner la compréhension du code. Nous gardons à l'idée que comprendre un code facilement est essentiel pour le maintenir, mais nous préférons mettre la priorité sur la catégorie restante : les erreurs majeures.
\\
\par Ces alertes Sonar proviennent de mauvaises pratiques de codage, qui ne gênent pas le bon déroulement du code, mais qui pour certaines d'entre elles, pourraient entrainer des erreurs lors d'ajout de code. Après cette première réduction du scope initial, nous avons fais le tri entre les alertes que nous pouvons corriger de façon automatique, et celles qui dépendent du contexte. Suite a cette seconde analyse, nous avons dressé le tableau en annexe 1 qui reprend les différentes alertes ainsi que la solution apportée.

\subsection{Détection d'erreur}
\par Afin de détecter les erreurs que nous voulons corriger, nous nous sommes appuyé sur la librairie Spoon, qui nous apporte une solution pour analyser du code Java. Pour chaque alerte, nous avons donc un une classe Processor associée dans laquelle nous décrivons le pattern à rechercher. Lorsque cette fonction trouve du code qui match, nous pouvons commencer sa transformation.

\section{La correction du code}

\section{Évaluation}
\subsection{Les test unitaires}
\subsection{Projets réels}
\par Dans le but de valider notre approche, nous avons décider de prendre des gros projets open-source possédant les alertes que nous sommes en mesure de réparer automatiquement. Ces projets sont les suivants : commons-lang, commons-math, log4j. L'annexe 2 montre les résultats obtenus suite à nos modifications. 



\newpage
\appendix
\begin{center}
	\section{Annexe 1 - Tableaux des correctifs}
	\begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
  	\hline
	  	\begin{center}
	  	 Noncompliant
	  	 \end{center} & 
	  	 \begin{center}
	  	 Compliant
	  	 \end{center} \\
  	\hline
	\begin{lstlisting}
if (myClass.compareTo(arg) == -1) {...}
  	\end{lstlisting} 
   	& 
   	\begin{lstlisting}
if (myClass.compareTo(arg) < 0) {...}
  	\end{lstlisting}  \\
  	\hline
	\begin{lstlisting}
class Bar {
  public boolean doSomething(){...}
}
class Foo extends Bar {
  public boolean doSomething(){...}
}
  	\end{lstlisting} 
   	& 
   	\begin{lstlisting}
class Bar {
  public boolean doSomething(){...}
}
class Foo extends Bar {
  @Override
  public boolean doSomething(){...}
}
  	\end{lstlisting}  \\
  	\hline
	\begin{lstlisting}
public void a(Map<String,Object> map) {
  for (String key : map.keySet()) {  
    Object value = map.get(key);
    ...
  }
}
  	\end{lstlisting} 
   	& 
   	\begin{lstlisting}
public void a(Map<String,Object> map) {
  for (Map.Entry<String,Object> entry : 
  	map.entrySet()) {
    String key = entry.getKey();
    Object value = entry.getValue();
    ...
  }
}
  	\end{lstlisting}  \\
  	\hline
	\begin{lstlisting}
foo.equals(bar.toUpperCase());
  	\end{lstlisting} 
   	& 
   	\begin{lstlisting}
foo.equalsIgnoreCase(bar);  
  	\end{lstlisting}  \\
  	\hline
	\begin{lstlisting}
switch (myVariable) {
  case 0: // 6 lines till next case
    methodCall1("");
    methodCall2("");
    methodCall3("");
    methodCall4("");
    break;
  case 1:
  ...
}
  	\end{lstlisting} 
   	& 
   	\begin{lstlisting}
switch (myVariable) {
  case 0:                  
    doSomething()
    break;
  case 1:
  ...
}
...
private void doSomething(){
    methodCall1("");
    methodCall2("");
    methodCall3("");
    methodCall4("");
} 
  	\end{lstlisting}  \\
  	\hline
	\begin{lstlisting}
public class MyClass {
  private int foo = 42;

  public int compute(int a) {
    return a * 42;
  }
}
  	\end{lstlisting} 
   	& 
   	\begin{lstlisting}
public class MyClass {
  public int compute(int a) {
    return a * 42;
  }
}
  	\end{lstlisting}  \\
  	\hline
	\begin{lstlisting}
class A { 
  private int field;
}
  	\end{lstlisting} 
   	& 
   	\begin{lstlisting}
class A {
  private int field;

  A(int field) {
    this.field = field;
  }
}
  	\end{lstlisting}  \\
  	\hline
\end{tabular}  
\end{center} 

\newpage
\begin{center}
	
	\begin{table}[]
\centering
\caption{Évaluation}
\label{my-label}
\begin{tabular}{c|c|c|c|c|c|}
\cline{2-6}
                                                    & Alerte ID           & Alertes & Alertes Fixés & \% Alertes Fixés & Test degradé \\ \hline
\multicolumn{1}{|c|}{\multirow{5}{*}{Commons-lang}} & ID\_override        & 2       &               &                  &              \\ \cline{2-6} 
\multicolumn{1}{|c|}{}                              & ID\_switch          & 23      & 23            & 100\%            & 1            \\ \cline{2-6} 
\multicolumn{1}{|c|}{}                              & ID\_private\_field  & 4       &               &                  &              \\ \cline{2-6} 
\multicolumn{1}{|c|}{}                              & ID\_equals          & 17      &               &                  &              \\ \cline{2-6} 
\multicolumn{1}{|c|}{}                              & ID\_instanceof\_try & 1       &               &                  &              \\ \hline
\multicolumn{1}{|c|}{\multirow{3}{*}{Commons-math}} & ID\_override        & 26      &               &                  &              \\ \cline{2-6} 
\multicolumn{1}{|c|}{}                              & ID\_switch          & 96      &               &                  &              \\ \cline{2-6} 
\multicolumn{1}{|c|}{}                              & ID\_equals          & 17      &               &                  &              \\ \hline
\multicolumn{1}{|c|}{\multirow{4}{*}{Log4j}}        & ID\_override        & 108     &               &                  &              \\ \cline{2-6} 
\multicolumn{1}{|c|}{}                              & ID\_switch          & 29      &               &                  &              \\ \cline{2-6} 
\multicolumn{1}{|c|}{}                              & ID\_equals          & 26      &               &                  &              \\ \cline{2-6} 
\multicolumn{1}{|c|}{}                              & ID\_instanceof\_try & 36      &               &                  &              \\ \hline
\end{tabular}
\end{table}
	
	
  
\end{center} 

\end{document}